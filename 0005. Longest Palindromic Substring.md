# 5. Longest Palindromic Substring

Given a string s, return *the longest palindromic substring* in s.

**Example 1:**  
Input: s = "babad"  
Output: "bab"  
Explanation: "aba" is also a valid answer.


## Approach 1: Longest Common Substring
***:x: Time Limit Exceeded***
```python3
class Solution:
    def longestPalindrome(self, s: str) -> str:  
        l = len(s)
        arr = [[0 for x in range(l)] for x in range(l)]
        r = s[::-1]
        largest = 0
        largest_idx = 0
        for i in range(l):
            for j in range(l):
                if s[i] == r[j]:
                    if i == 0 or j == 0:
                        arr[i][j] = 1
                    else:
                        arr[i][j] = arr[i - 1][j - 1] + 1
                    if arr[i][j] > largest and i - arr[i][j] + 2 == l - j:
                        largest = arr[i][j]
                        largest_idx = i
        return s[largest_idx - largest + 1: largest_idx + 1]
```
> **Complexity Analysis**
> 
> * Time complexity: O(n^2).
> 
> * Space complexity: O(n^2) (could be improved to use O(n) space).

### Improve Space Complexity
***:x: Time Limit Exceeded***
```python3
class Solution:
    def longestPalindrome(self, s: str) -> str:  
        l = len(s)
        arr = [0 for x in range(l)]
        r = s[::-1]
        largest = 0
        largest_idx = 0
        for i in range(l):
            for j in range(l - 1, -1, -1):
                if s[i] == r[j]:
                    if i == 0 or j == 0:
                        arr[j] = 1
                    else:
                        arr[j] = arr[j - 1] + 1
                    if arr[j] > largest and i - arr[j] + 2 == l - j:
                        largest = arr[j]
                        largest_idx = i
                else:
                    arr[j] = 0
        return s[largest_idx - largest + 1: largest_idx + 1]
```


## Approach 2: Dynamic Programming
***:x: Time Limit Exceeded***
```python3
class Solution:
    def longestPalindrome(self, s: str) -> str:     
        l = len(s)
        arr = [[False for x in range(l)] for x in range(l)]
       
        largest = 1
        largest_idx = 0
       
        for j in range(l):
            arr[j][j] = True
            for i in range(j):
                arr[i][j] = s[i] == s[j] and (j - i == 1 or arr[i + 1][j - 1])
                if arr[i][j] and j - i + 1 > largest:
                    largest = j - i + 1
                    largest_idx = i
                       
        return s[largest_idx : largest_idx + largest]
```
> **Complexity Analysis**
> 
> * Time complexity: O(n^2).
> 
> * Space complexity: O(n^2) (could be improved to use O(n) space).

### Improve Space Complexity
```python3
class Solution:
    def longestPalindrome(self, s: str) -> str:  
        l = len(s)
        arr = [False for x in range(l)]
       
        largest = 1
        largest_idx = 0
       
        for j in range(l):
            arr[j] = True
            for i in range(j):
                arr[i] = s[i] == s[j] and (j - i == 1 or arr[i + 1])
                if arr[i] and j - i + 1 > largest:
                    largest = j - i + 1
                    largest_idx = i
        
        return s[largest_idx : largest_idx + largest]
```


## Approach 3: Expand Around Center
```python3

```

### Fill the string with \#
```python3
class Solution:
    def longestPalindrome(self, s: str) -> str:
        str = []
        for i in range(len(s)):
            str.append("#")
            str.append(s[i])
        str.append("#")
        
        largest = 0
        largest_idx = 0
        for i in range(1, len(str) - 1):
            j = 1
            while i - j >=0 and i + j < len(str) and str[i - j] == str[i + j]:
                if j > largest:
                    largest = j
                    largest_idx = (i + j) // 2 - 1
                j = j + 1
        
        return s[largest_idx - largest + 1 : largest_idx + 1]
```


## Approach 4: Manacher's Algorithm
